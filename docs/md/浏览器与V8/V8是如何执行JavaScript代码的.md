# V8是如何执行JavaScript代码的

很多前端开发人员只是单纯的使用 JavaScript 或者前端框架，对 V8 认识不足并且不了解 V8 执行 JavaScript 的过程。搞清楚了这个问题，我们可以写出性能更好也更优雅的 JavaScript 代码，同时，也能帮助我们更轻松的理解 Babel 执行的原理、ESLint 的检查机制、React 或 Vue 的底层实现等，以后面对层出不穷的新技术和框架也能更轻松的去学习掌握。

## 什么是V8

V8 是用 C++ 编写的 Google 开源高性能 `JavaScript` 和 `WebAssembly` 引擎，目前被广泛的应用在各种 JavaScript 执行环境中，如 Chrome 浏览器、Node.js、Electron、Deno 等。

它实现了`ECMAScript` 和 `WebAssembly` ，并在 Window 7 或更高版本，macOS 10.12+ 和使用 x64，IA-12，ARM 或 MIPS 处理器的 Linux 系统上运行。

V8 引擎可以独立运行，也可以嵌入到任何 C++ 应用程序中。

简单的说，V8 的作用就是帮助我们将 JavaScript 代码转化为CPU可以直接运行的代码。

## 编译执行、解释执行以及JIT

对 V8 有一个初步认识之后，我们再来看几个概念。

CPU 只能处理 由 0 / 1 组成的二进制指令，也就是机器语言。但是对我们程序员来说，二进制代码是不能阅读和记忆的，于是我们又将二进制的指令转换为可以识别和记忆的语言，这就是汇编语言。但是汇编语言也是相对比较底层的，后来就有了程序员专门处理业务逻辑的语言，如 C、C++、Java、JavaScript、Python 等，这些语言都属于高级语言。

CPU 是不能直接识别和执行高级语言所编写的代码，通常有两种方式来执行这些代码。

**解释执行**

将输入的源代码通过解析器编译成中间代码，然后直接使用解释器去解释执行中间代码。

**编译执行**

编译执行也需要将源代码转换为中间代码，然后编译器再将中间代码编译成机器代码。

以上是执行高级语言代码的两种基本的方式，那么 V8 执行 JavaScript 代码又是采用哪种呢？实际上，V8 是混合了编译执行和解释执行两种手段，我们把这种混合的方式称为 JIT（Just In Time）。

使用 JIT 是由于编译执行和解释执行各自都有优缺点，解释执行的启动速度快，但是执行速度慢，而编译执行的启动速度慢，但是执行速度快。

## V8 的架构

2008 年 V8 发布，性能远超同时期的其他 JS 引擎。这是由于 V8 当时的架构比较激进，直接将 JavaScript 代码编译为机器码并执行，所以其执行速度很快。

后来经过不断的发展，V8 一直在探索对代码的优化方式，其中经过了很多个版本更迭的变化。在 2017 年发布的 v8.5.9 版本后，基本上 V8 的架构便稳定了下来。

在执行 JavaScript 的过程中，最核心的是三个模块：解析器（Parser），解释器（Ignition）,优化编译器（TurboFan）。

## 执行过程

![](.\img\v8.png)

V8 执行 JavaScript 源码时，首先解析器（Parser）会将源码解析为抽象语法树（Abstract Syntax Tree），接下来解释器（Ignition）会将 AST 转换为字节码，一边解释一边执行。

在解释器解释执行时，会监控特定代码的运行次数，如果某个代码片段次数较高超过了某个阈值，那么这段代码就会被标记为热点代码，并交给优化编译器（TurboFan），优化编译器会优化并编译字节码，最终生成优化后的机器码，这样当该段代码再次执行时，解释器就直接使用优化的机器码执行，提高代码运行的效率。

当热点代码被更改时，优化编译器又会将他交给解释器去转换成字节码执行，这个过程叫反优化。

以上便是 V8 执行的大致过程，下面我们再来进行一些详细的分析。

### 解析器 Parser

V8 将使用解析器（Parser）模块源码解析成一个抽象语法树，这个过程被称为解析（Parsing）。

解析可以分为词法分析和语法分析两个部分。

词法分析就是将我们编写的代码转换为tokens，token指的是语法上不能再分割的最小单位。例如， `var a = '1'`就会被解析成 `var ` `a` `=` `'1'`几个token。词法分析由 Scanner 来完成。

语法分析将 tokens 转换为 AST。这个过程如果源码不符合语法规则，解析过程就会终止并抛出语法错误。语法分析由Parser 和 Pre-Parser来完成。

在这个过程中，V8 也生成了该段代码的作用域。

如果将所有的 JavaScript 全部解析的话，会面临代码执行时间长、消耗内存、占用磁盘空间等问题，所以 V8 使用了**惰性解析（Lazy Parsing）**。

惰性解析指的是：在解析的过程中，碰到不是立即执行的函数，只进行预解析；只有函数有调用时，才对函数进行全量的解析。

Pre-Parser解析器进行预解析，该过程中只会解析函数声明，不会解析函数内部代码，也不会为函数内部代码生成AST。

### 解释器 Ignition

由于JavaScript代码转换为机器代码后占用空间过大，所以引入了字节码。字节码是对机器码的抽象，类似汇编。

解释器在执行字节码时，主要使用 通用寄存器和累加寄存器，函数参数和局部变量都保存在通用寄存器中，累加寄存器用于保存中间结果。

### 优化编译器 TurboFan

V8 在优化编译方面做了很多工作，其中最主要的有内联和逃逸分析两种算法。

内联优化将我们编写的有函数中调用函数的代码内立案到一个函数中，这样编译生成的机器码会精简很多，执行效率也有很大的提升。

逃逸分析是根据对象对象是否仅用于当前函数内来进行优化。如果对象只在函数内部定义，并且对象只作用于函数内部的话，就会被认为是“未逃逸”的。对未逃逸的对象会把他优化为普通变量的形式，优化后不再需要从内存中访问对象属性，这样便减少了内存消耗，并且提升了执行效率。

## 总结

最初的 V8 直接将 JavaScript 源码编译为机器码进行执行，这种架构导致内存占用过高，所以后来引入了 字节码 。V8 执行 JavaScript 主要分为三个步骤：

- 解析器将 JavaScript 源码解析成 AST，解析过程分为词法分析与语法分析，V8 通过预解析提升解析效率
- 解释器根据 AST 生成字节码并执行。这个过程会监听热点代码，将收集的信息交给 优化编译器TurboFan进行优化编译
- TurboFan将热点代码编译为优化后的机器码，后续解释器将执行优化机器码，进而提升性能

