# HTTPS

**为什么有HTTPS？因为HTTP不安全。**

明文传输，代理服务等有严重的安全隐患。



**什么是安全？**

机密性、完整性、身份认证、不可否认



**什么是HTTPS？**

协议名为 https，默认端口号443，其他语法语义与HTTP完全一致。

它把 HTTP下层的传输协议由TCP/IP换成了SSL/TLS，让HTTP运行到了安全的SSL/TLS协议上。



**SSL/TLS**

SSL 即安全套接层，在 OSI 模型中处于第五层（会话层），有 V2 和 V3 两个版本。

后改名为 TLS（传输层安全），正式标准化，版本号从 1.0 重新算起。

目前应用最广泛的是 TLS 1.2，最新的是 TLS 1.3。

TLS 由记录协议、握手协议、警告协议、变更密码规范协议、扩展协议等几个子协议组成，综合使用了对称加密、非对称加密、身份认证等许多密码学前沿技术。

浏览器和服务器在使用 TLS 建立连接时，需要选择一组恰当的加密算法来实现安全通信，这些算法的组合被称为“密码套件”（也叫加密套件）。

## **加密**

实现机密性最常用的手段是“加密”，解密的钥匙叫“密钥”，加密前的消息叫“明文”，加密后的乱码叫“密文”，使用密钥还原明文的过程叫“解密”，是加密的反操作，加密解密的操作过程就是“加密算法”。

按照密钥的使用方式，加密可以分为：对称加密和非对称加密。

### 对称加密

对称加密指加密和解密时使用的密钥都是同一个，是对称的。只要保证了密钥安全，那整个通信过程就可以说具有了机密性。

TLS 目前常用的加密算法是 AES 和 ChaCha20。

对称算法还有一个“分组模式”的概念，它可以让算法用固定长度的我密钥加密任意长度的明文。最新的分组模式被称为AEAD。

### 非对称加密

如何安全的进行“密钥交换”？，所以出现了非对称加密。

它有两个密钥，一个叫“公钥”，一个叫“私钥”，两个密钥是不同的，所以是非对称的。

公钥和私钥有“单向”性，公钥加密后只能私钥解密，私钥加密后只能用公钥解密。非对称加密可以解决“密钥交换”的问题。

非对称加密算法的设计要比对称加密算法难得多，RAS的安全性基于“整数分解”，ECC基于“椭圆曲线离散对数”。

### 混合加密

非对称加密没有“密钥交换”的问题，但运算速度慢，所以 TLS 里使用了 混合加密 方式。

在通信开始时使用非对称加密，解决密钥交换的问题，然后使用随机数产生对称算法使用的“会话密钥”，再用公钥加密。对方拿到密文后用私钥解密，去除会话密钥。这样，双方就实现了密钥的安全交换，后续就全使用对称加密。

## 数字签名与证书

通过对称加密和非对称加密，以及两者结合的混合加密，实现了机密性，但离安全还差的很远，需要加上完整性、身份认证等特性才能实现真正的安全。

### 摘要算法

实现完整性的手段主要是 “摘要算法”，也就是常说的散列函数、哈希函数。

摘要算法可以理解为，能把任意长度的数据“压缩”成固定长度、而且独一无二的摘要字符串。

目前 TLS  推荐使用的是 SHA-2，它是一些列摘要算法的铜川，常用的有 SHA224、SHA256、SHA384。

### 完整性

摘要算法保证了“数字摘要”和原文是完全等价的，所以只要在原文后附上它的摘要，就能够保证数据的完整性。

服务端在拿到消息后，也计算消息的摘要，将摘要进行对比，如果一致就说明消息是完整可信的，没有被修改。

不过摘要算法不具有机密性，如果明文传输，那么黑客就可以修改消息后把摘要一起改了，网站还是鉴别不出完整性。

所以，真正的完整性必须要建立在机密性之上，在混合加密系统里用会话密钥加密消息和摘要，这样黑客无法得知明文，就保证了安全。这个术语叫：哈希消息认证码。

### 数字签名

加密算法结合摘要算法，通信过程就可以说比较安全了，但是还有漏洞，就是通信的两个端点。

为了证明数字世界里你的身份，可以使用私钥加摘要算法，就能够实现“数字签名”，同时实现“身份认证”和“不可否认”。

数字签名的原理很简单，就是把公钥私钥的用法反过来，之前是公钥加密、私钥解密，现在是私钥加密、公钥解密。

但又因为非对称加密效率太低，所以私钥只加密原文的摘要，这样运算量也小得多，而且得到的数字签名也很小，方便保管和传输。

签名和公钥一样完全公开，任何人都可以获取。但这个签名只有用私钥对应的公钥才能解开，拿到摘要后，再比对原文验证完整性，就可以像签署文件一样证明消息确实是你发的。

这两个行为叫做“签名”和“验签”。因为私钥保密，黑客不能伪造签名，就能保证通信双方的身份。

### 数字证书和CA

找一个公认的可信第三方，让它构建起公钥的信任链。这个第三方就是我们常说的 CA（证书认证机构）。

CA对公钥的签名认证也是有格式的，不是简单地把公钥绑定在持有者身份上就完事了，还要包含序列号、用户、颁发者、有效时间等等，把这些打成一个包再签名，完整地证明公钥关联的各种信息，形成 “数字证书”。